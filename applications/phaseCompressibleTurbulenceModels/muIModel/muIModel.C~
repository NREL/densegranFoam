/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 2013-2016 OpenFOAM Foundation
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

\*---------------------------------------------------------------------------*/

#include "muIModel.H"
#include "mathematicalConstants.H"
#include "twoPhaseSystem.H"
#include "fvOptions.H"


// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

Foam::RASModels::muIModel::muIModel
(
    const volScalarField& alpha,
    const volScalarField& rho,
    const volVectorField& U,
    const surfaceScalarField& alphaRhoPhi,
    const surfaceScalarField& phi,
    const transportModel& phase,
    const word& propertiesName,
    const word& type
)
:
  eddyViscosity
  <
  RASModel<EddyDiffusivity<phaseCompressibleTurbulenceModel>>
  >
  (
   type,
   alpha,
   rho,
   U,
   alphaRhoPhi,
   phi,
   phase,
   propertiesName
   ),
  phase_(phase),
  Hmax_("Hmax", dimLength, coeffDict_),
  L_("L", dimless, coeffDict_),
  nu0_("nu0", dimLength*dimLength/dimTime, coeffDict_),
  muS_("muS", dimless, coeffDict_),
  mu2_("mu2", dimless, coeffDict_),
  nNormalCell(readScalar(coeffDict_.lookup("Ncell"))),
  alpha0_(readScalar(coeffDict_.lookup("alpha0"))),
  phiMuI_(readScalar(coeffDict_.lookup("phiMuI"))),
  Cs_(readScalar(coeffDict_.lookup("Cs"))),
  ampl_(readScalar(coeffDict_.lookup("pres_ampl"))),
  beta_(readScalar(coeffDict_.lookup("beta"))),
  theta_(readScalar(coeffDict_.lookup("theta"))),
  rhoS("rhoS", dimensionSet(1, -3, 0, 0, 0),coeffDict_.lookup("rhoSVal")),
  relaxPa_(readScalar(coeffDict_.lookup("relaxPa"))),
  nuMin_(readScalar(coeffDict_.lookup("nuMin"))),
  Fr_("Fr", dimensionSet(1, -1, -2, 0, 0), coeffDict_),
  etaPF_("etaPF", dimless, coeffDict_),
  p_("p", dimless, coeffDict_),
  alphaDeltaMin_("alphaDeltaMin", dimless, coeffDict_),
  alphaMinFriction("alphaMinFriction", dimless, coeffDict_),
  Bphi("Bphi",dimless,coeffDict_),
  g0_
  (
   "g0",
   dimensionSet(1, -1, -2, 0, 0),
   coeffDict_.lookup("g0")
   ),
  ppres
  (
   IOobject
   (
    "ppres",
    U_.time().timeName(),
    U_.mesh(),
    IOobject::MUST_READ,
    IOobject::AUTO_WRITE
    ),
   U_.mesh()
   ),
  g_(U.db().lookupObject<uniformDimensionedVectorField>("g")),
  tau
  (
   IOobject
   (
    "tau",
    U_.time().timeName(),
    U_.mesh(),
    IOobject::NO_READ,
    IOobject::AUTO_WRITE
    ),
   rho_*2*nut_*scalar(0.5)*(fvc::grad(U_)+fvc::grad(U_)().T())*scalar(0.0)
   ),
  eta
  (
   IOobject
   (
    "eta",
    U_.time().timeName(),
    U_.mesh(),
    IOobject::NO_READ,
    IOobject::AUTO_WRITE
    ),
   nut_*scalar(0.0)
   ),
  lambda_
    (
        IOobject
	(
            IOobject::groupName("lambda", phase.name()),
            U.time().timeName(),
            U.mesh(),
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        U.mesh(),
     	dimensionedScalar("zero", dimensionSet(0, 2, -1, 0, 0), 0.0)
    ),
  href_nlgf
    (
     IOobject
     (
      "href_nlgf",
      U_.time().timeName(),
      U_.mesh(),
      IOobject::MUST_READ,
      IOobject::AUTO_WRITE
      ),
     U_.mesh()
     )
{
  //  nut_ == dimensionedScalar("zero", nut_.dimensions(), 0.0);
  if (type == typeName)
      {
        printCoeffs(type);
      }
}


// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //

Foam::RASModels::muIModel::~muIModel()
{}


// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

bool Foam::RASModels::muIModel::read()
{
    if
    (
        eddyViscosity
    <
        RASModel<EddyDiffusivity<phaseCompressibleTurbulenceModel>>
    >::read()
    )
    {
        coeffDict().lookup("Hmax") >> Hmax_;
	coeffDict().lookup("L") >> L_;
	coeffDict().lookup("nu0") >> L_;
	coeffDict().lookup("muS") >> muS_;
	coeffDict().lookup("mu2") >> mu2_;
	coeffDict().lookup("Ncell") >> nNormalCell;
	coeffDict().lookup("alpha0") >> alpha0_;
	coeffDict().lookup("phiMuI") >> phiMuI_;
	coeffDict().lookup("Cs") >> Cs_;
	coeffDict().lookup("pres_ampl") >> ampl_;
	coeffDict().lookup("beta") >> beta_;
	coeffDict().lookup("theta") >> theta_;
	coeffDict().lookup("rhoSVal") >> rhoS;
        coeffDict().lookup("relaxPa") >> relaxPa_;
	coeffDict().lookup("nuMin") >> nuMin_;
	Fr_.read(coeffDict_);
	etaPF_.read(coeffDict_);
	p_.read(coeffDict_);
	alphaDeltaMin_.read(coeffDict_);
	alphaMinFriction.read(coeffDict_);
	Bphi.read(coeffDict_);
	g0_.readIfPresent(coeffDict());

        return true;
    }
    else
    {
        return false;
    }
}


Foam::tmp<Foam::volScalarField>
Foam::RASModels::muIModel::k() const
{
    NotImplemented;
    return nut_;
}


Foam::tmp<Foam::volScalarField>
Foam::RASModels::muIModel::epsilon() const
{
    NotImplemented;
    return nut_;
}


Foam::tmp<Foam::volSymmTensorField>
Foam::RASModels::muIModel::R() const
{
    return tmp<volSymmTensorField>
    (
        new volSymmTensorField
        (
            IOobject
            (
                IOobject::groupName("R", U_.group()),
                runTime_.timeName(),
                mesh_,
                IOobject::NO_READ,
                IOobject::NO_WRITE
            ),
	    - (nut_)*dev(twoSymm(fvc::grad(U_)))
          - (lambda_*fvc::div(phi_))*symmTensor::I
        )
    );
}


Foam::tmp<Foam::volScalarField>
Foam::RASModels::muIModel::pPrime() const
{
  const volScalarField& rho = phase_.rho();
  
  volScalarField K_("K_",rho*mag(g_)*Hmax_);

  //  dimensionedScalar small_p("small_p", dimMass/dimLength/dimTime/dimTime, 0.0);
  volScalarField pfprime
    ("pfprime",
     Fr_*
     (
      etaPF_*pow(max(alpha_ - alphaMinFriction, scalar(0)), etaPF_ - 1.0)
      /max(alpha0_-alpha_, alphaDeltaMin_)//      /pow(max(alpha0_-alpha_, alphaDeltaMin_), p_)
      + p_*pow(max(alpha_ - alphaMinFriction, scalar(0)), etaPF_)
      )/pow(max(alpha0_ - alpha_, alphaDeltaMin_), p_ + 1.0)
     );

  volScalarField pKp
    ("pKp",
     g0_
     *
     (
      exp(ampl_*(alpha_ - alpha0_))
      )
    );
  dimensionedScalar smallval_p("smallval_p", dimMass/dimLength/dimTime/dimTime, 1e-6);
  dimensionedScalar smLin("smLin", dimless/dimLength/dimLength, scalar(1e-6));
  tmp<volScalarField> tpPrime
    (
     (max(tr((fvc::grad(nlgfPre()))*(-fvc::grad(alpha0_-alpha_)
				     /max(mag(fvc::grad(alpha0_-alpha_))*mag(fvc::grad(alpha0_-alpha_)),smLin))), smallval_p)
      +pfprime)//ppres*(scalar(1.0)+alpha_)*exp(ampl_*(alpha_ - alpha0_))+pfprime//mag(fvc::grad(ppres))/max(mag(fvc::grad(max\
     //(alpha0_-alpha_,scalar(0.0)))),smLin)//ppres*exp(ampl_*(alpha_ - alpha0_))//+pfprime
//(pfprime+ppres*(alpha_/alpha0_))//K_*(alpha_/alpha0_)+pfprime//pfprime+ppres*alpha_/alpha0_//K_*(alpha_/alpha0_)
     );
  volScalarField tpPrimeO
  (
   "tpPrimeO",
   max(tr((fvc::grad(nlgfPre()))*(-fvc::grad(alpha_)/max(mag(fvc::grad(alpha_))*mag(fvc::grad(alpha_)),smLin))),smallval_p)
     +pfprime
   //ppres*exp(ampl_*(alpha_ - alpha0_))//max(alpha0_-alpha_, alphaDeltaMin_)//mag(fvc::grad(ppres))/max(mag(fvc::grad(alpha0_-alpha_)),smLin\
   )
  //     +pfprime//ppres*(scalar(1.0)+alpha_)*exp(ampl_*(alpha_ - alpha0_))+pfprime//mag(fvc::grad(ppres))/max(mag(fvc::grad(max(alpha0\
    //_-alpha_,scalar(0.0)))),smLin)//ppres*exp(ampl_*(alpha_ - alpha0_))//+pfprime
//pfprime+ppres*(alpha_/alpha0_)//K_*(alpha_/alpha0_)+pfprime//pfprime+ppres*alpha_/alpha0_//K_*(alpha_/alpha0_)
    );  
    Info<<min(tpPrimeO)<<endl;
    Info<<max(tpPrimeO)<<endl;

    if(U_.time().outputTime())
    {
      tpPrimeO.write();
    }
  
  volScalarField ppri("ppri", K_/alpha0_);
  if(U_.time().outputTime())
    {
      ppri.write();
    }
  
    volScalarField::Boundary& bpPrime =
        tpPrime.ref().boundaryFieldRef();

    forAll(bpPrime, patchi)
    {
        if (!bpPrime[patchi].coupled())
        {
            bpPrime[patchi] == 0;
        }
    }

    return tpPrime;
}


Foam::tmp<Foam::surfaceScalarField>
Foam::RASModels::muIModel::pPrimef() const
{
  return fvc::interpolate(pPrime());
}


Foam::tmp<Foam::volSymmTensorField>
Foam::RASModels::muIModel::devRhoReff() const
{
    return tmp<volSymmTensorField>
    (
        new volSymmTensorField
        (
            IOobject
            (
                IOobject::groupName("devRhoReff", U_.group()),
                runTime_.timeName(),
                mesh_,
                IOobject::NO_READ,
                IOobject::NO_WRITE
            ),
	    - (rho_*nut_)
	    *dev(twoSymm(fvc::grad(U_)))
	    - ((rho_*lambda_)*fvc::div(phi_))*symmTensor::I
	 )
    );
}


Foam::tmp<Foam::fvVectorMatrix>
Foam::RASModels::muIModel::divDevRhoReff
(
    volVectorField& U
) const
{

  bool debug=true;

  Info<<"constructing divDevRhoReff"<<endl;
  return
    (
      - fvm::laplacian(rho_*nut_, U)
      - fvc::div
        (
            (rho_*nut_)*dev2(T(fvc::grad(U)))
          + ((rho_*lambda_)*fvc::div(phi_))
           *dimensioned<symmTensor>("I", dimless, symmTensor::I)
           )
    );
}

Foam::tmp<Foam::volScalarField>
Foam::RASModels::muIModel::nlgfPre() const
{
  tmp<volScalarField> tda(phase_.d());
  const volScalarField& da = tda();

  dimensionedScalar smallval_sr("smallval_sr", dimless/dimTime, 1e-6);
  dimensionedScalar largeval_sr("largeval_sr", dimless/dimTime, 1e2);
  dimensionedScalar smallval_p("smallval_p", dimMass/dimLength/dimTime/dimTime, 1e-6);
  volScalarField srnz("srnz", max(sqrt(2.0)*mag(symm(fvc::grad(U_))),smallval_sr));
  volScalarField K_("K_",rhoS*alpha_*mag(g_)*Hmax_);
  volScalarField ppK("ppK", K_*ampl_*max(alpha_ - alphaMinFriction, scalar(0)));
  volScalarField pp("pp", pow(Bphi*alpha_/max(alpha0_ - alpha_, alphaDeltaMin_), 2)*rho_*pow(da, 2)*pow(srnz, 2)*
		    max(alpha_ - alphaMinFriction, scalar(0)));
  /*
    volScalarField pf("pf",
    Fr_*pow(max(alpha_ - alphaMinFriction, scalar(0)), etaPF_)
    /pow(max(alpha0_ - alpha_, alphaDeltaMin_), p_)
    //Fr_/pow(max(alpha0_ - alpha_, alphaDeltaMin_), p_)
    );
  */  
  if(U_.time().outputTime())
    {
      srnz.write();
      pp.write();
      ppK.write();
    }
  
  return max(pp,smallval_p);
}


void Foam::RASModels::muIModel::correct()
{

  const volScalarField& rho = phase_.rho();
  const volVectorField& U = U_;
  
  tmp<volScalarField> tda(phase_.d());
  const volScalarField& da = tda();
  
  dimensionedScalar smallval_sr("smallval_sr", dimless/dimTime, 1e-6);
  dimensionedScalar largeval_sr("largeval_sr", dimless/dimTime, 1e2);
  dimensionedScalar minNu("minNu", dimLength*dimLength/dimTime, nuMin_);  
  dimensionedScalar smallval_p("smallval_p", dimMass/dimLength/dimTime/dimTime, 1e-6);
  dimensionedScalar rhodada("rhodada", dimMass/dimLength, 1e-6);
  dimensionedScalar I0("I0", (mu2_-muS_)/Bphi);
  volScalarField srnz("srnz", sqrt(2.0)*mag(symm(fvc::grad(U_))));
  volScalarField zeta("zeta", I0/sqrt(alpha_*rho*da*da+rhodada));
  volScalarField pf("pf",
                    Fr_*pow(max(alpha_ - alphaMinFriction, scalar(0)), etaPF_)
                    /pow(max(alpha0_ - alpha_, alphaDeltaMin_), p_)
                    //Fr_/pow(max(alpha0_ - alpha_, alphaDeltaMin_), p_)
                    );
  
  volScalarField tau_inv_par = relaxPa_*srnz;
  fvScalarMatrix ppresEqn
    (
     fvm::ddt(ppres)
     + fvm::div(phi_, ppres)
     - fvm::Sp(fvc::div(phi_), ppres)
     ==
       tau_inv_par*(nlgfPre()+pf)
     -fvm::Sp(tau_inv_par, ppres)
     );
  
  
  ppresEqn.relax();
  ppresEqn.solve();
  
  ppres.correctBoundaryConditions();
  ppres.max(smallval_p);

  
  volScalarField pa("pa", nlgfPre()+pf);
  
  
  //    volScalarField pa("pa", alpha_*ppres*exp(ampl_*(alpha_ - alpha0_))+pf);
  
  Info<<max(ppres)<<endl;
  Info<<min(ppres)<<endl;

  if(U_.time().outputTime())
    {
      ppres.write();
      pa.write();
      pf.write();
    }

  volScalarField muI_I("muI_I", srnz*da*sqrt(rhoS/pa));
  volScalarField muI("muI", muS_+(mu2_-muS_)/(I0/muI_I+scalar(1.0)));

  if(U_.time().outputTime())
    {
      muI_I.write();
      muI.write();
    }
  
  nut_ = muI*pa/rhoS/sqrt(pow(srnz,2)+pow(smallval_sr,2));//,nu0_),minNu);
  lambda_ = nut_*scalar(0.0);
  
  bool debug=true;
  if(debug)
    {
      Info<<min(nut_)<<"\n";
      Info<<max(nut_)<<"\n";
    }
}


// ************************************************************************* //
